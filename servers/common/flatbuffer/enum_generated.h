// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
#define FLATBUFFERS_GENERATED_ENUM_MAKGA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "version_generated.h"

namespace makga {

enum ServerType : int32_t {
  ServerType_Billing = 0,
  ServerType_Login = 1,
  ServerType_World = 2,
  ServerType_Community = 3,
  ServerType_DBAgent = 4,
  ServerType_Game = 5,
  ServerType_Instance = 6,
  ServerType_Web = 7,
  ServerType_Log = 8,
  ServerType_MIN = ServerType_Billing,
  ServerType_MAX = ServerType_Log
};

inline const ServerType (&EnumValuesServerType())[9] {
  static const ServerType values[] = {
    ServerType_Billing,
    ServerType_Login,
    ServerType_World,
    ServerType_Community,
    ServerType_DBAgent,
    ServerType_Game,
    ServerType_Instance,
    ServerType_Web,
    ServerType_Log
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[10] = {
    "Billing",
    "Login",
    "World",
    "Community",
    "DBAgent",
    "Game",
    "Instance",
    "Web",
    "Log",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (::flatbuffers::IsOutRange(e, ServerType_Billing, ServerType_Log)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum DatabaseType : int32_t {
  DatabaseType_NONE = 0,
  DatabaseType_MIN = DatabaseType_NONE,
  DatabaseType_MAX = DatabaseType_NONE
};

inline const DatabaseType (&EnumValuesDatabaseType())[1] {
  static const DatabaseType values[] = {
    DatabaseType_NONE
  };
  return values;
}

inline const char * const *EnumNamesDatabaseType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatabaseType(DatabaseType e) {
  if (::flatbuffers::IsOutRange(e, DatabaseType_NONE, DatabaseType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatabaseType()[index];
}

enum RedisType : int32_t {
  RedisType_NONE = 0,
  RedisType_MIN = RedisType_NONE,
  RedisType_MAX = RedisType_NONE
};

inline const RedisType (&EnumValuesRedisType())[1] {
  static const RedisType values[] = {
    RedisType_NONE
  };
  return values;
}

inline const char * const *EnumNamesRedisType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedisType(RedisType e) {
  if (::flatbuffers::IsOutRange(e, RedisType_NONE, RedisType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRedisType()[index];
}

enum AccountType : int32_t {
  AccountType_NONE = 0,
  AccountType_MIN = AccountType_NONE,
  AccountType_MAX = AccountType_NONE
};

inline const AccountType (&EnumValuesAccountType())[1] {
  static const AccountType values[] = {
    AccountType_NONE
  };
  return values;
}

inline const char * const *EnumNamesAccountType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountType(AccountType e) {
  if (::flatbuffers::IsOutRange(e, AccountType_NONE, AccountType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccountType()[index];
}

enum SessionType : int32_t {
  SessionType_None = 0,
  SessionType_User = 1,
  SessionType_MIN = SessionType_None,
  SessionType_MAX = SessionType_User
};

inline const SessionType (&EnumValuesSessionType())[2] {
  static const SessionType values[] = {
    SessionType_None,
    SessionType_User
  };
  return values;
}

inline const char * const *EnumNamesSessionType() {
  static const char * const names[3] = {
    "None",
    "User",
    nullptr
  };
  return names;
}

inline const char *EnumNameSessionType(SessionType e) {
  if (::flatbuffers::IsOutRange(e, SessionType_None, SessionType_User)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSessionType()[index];
}

enum MessageType : int32_t {
  MessageType_GridAddActor = 0,
  MessageType_GridRemoveActor = 1,
  MessageType_GridBroadcastMove = 2,
  MessageType_MIN = MessageType_GridAddActor,
  MessageType_MAX = MessageType_GridBroadcastMove
};

inline const MessageType (&EnumValuesMessageType())[3] {
  static const MessageType values[] = {
    MessageType_GridAddActor,
    MessageType_GridRemoveActor,
    MessageType_GridBroadcastMove
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[4] = {
    "GridAddActor",
    "GridRemoveActor",
    "GridBroadcastMove",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_GridAddActor, MessageType_GridBroadcastMove)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum TickGroup : int32_t {
  TickGroup_PrePhysics = 0,
  TickGroup_Physics = 1,
  TickGroup_PostPhysics = 2,
  TickGroup_PostUpdate = 3,
  TickGroup_Max = 4,
  TickGroup_MIN = TickGroup_PrePhysics,
  TickGroup_MAX = TickGroup_Max
};

inline const TickGroup (&EnumValuesTickGroup())[5] {
  static const TickGroup values[] = {
    TickGroup_PrePhysics,
    TickGroup_Physics,
    TickGroup_PostPhysics,
    TickGroup_PostUpdate,
    TickGroup_Max
  };
  return values;
}

inline const char * const *EnumNamesTickGroup() {
  static const char * const names[6] = {
    "PrePhysics",
    "Physics",
    "PostPhysics",
    "PostUpdate",
    "Max",
    nullptr
  };
  return names;
}

inline const char *EnumNameTickGroup(TickGroup e) {
  if (::flatbuffers::IsOutRange(e, TickGroup_PrePhysics, TickGroup_Max)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTickGroup()[index];
}

enum AIType : int32_t {
  AIType_Aggressive = 0,
  AIType_NonAggressive = 1,
  AIType_Coward = 2,
  AIType_FieldBoss = 3,
  AIType_InstanceBoss = 4,
  AIType_Character = 5,
  AIType_Sandbag = 6,
  AIType_MIN = AIType_Aggressive,
  AIType_MAX = AIType_Sandbag
};

inline const AIType (&EnumValuesAIType())[7] {
  static const AIType values[] = {
    AIType_Aggressive,
    AIType_NonAggressive,
    AIType_Coward,
    AIType_FieldBoss,
    AIType_InstanceBoss,
    AIType_Character,
    AIType_Sandbag
  };
  return values;
}

inline const char * const *EnumNamesAIType() {
  static const char * const names[8] = {
    "Aggressive",
    "NonAggressive",
    "Coward",
    "FieldBoss",
    "InstanceBoss",
    "Character",
    "Sandbag",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIType(AIType e) {
  if (::flatbuffers::IsOutRange(e, AIType_Aggressive, AIType_Sandbag)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIType()[index];
}

enum ActorType : int32_t {
  ActorType_None = 0,
  ActorType_Character = 1,
  ActorType_Monster = 2,
  ActorType_Gadget = 3,
  ActorType_Object = 4,
  ActorType_MIN = ActorType_None,
  ActorType_MAX = ActorType_Object
};

inline const ActorType (&EnumValuesActorType())[5] {
  static const ActorType values[] = {
    ActorType_None,
    ActorType_Character,
    ActorType_Monster,
    ActorType_Gadget,
    ActorType_Object
  };
  return values;
}

inline const char * const *EnumNamesActorType() {
  static const char * const names[6] = {
    "None",
    "Character",
    "Monster",
    "Gadget",
    "Object",
    nullptr
  };
  return names;
}

inline const char *EnumNameActorType(ActorType e) {
  if (::flatbuffers::IsOutRange(e, ActorType_None, ActorType_Object)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActorType()[index];
}

enum CityType : int32_t {
  CityType_NONE = 0,
  CityType_MIN = CityType_NONE,
  CityType_MAX = CityType_NONE
};

inline const CityType (&EnumValuesCityType())[1] {
  static const CityType values[] = {
    CityType_NONE
  };
  return values;
}

inline const char * const *EnumNamesCityType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCityType(CityType e) {
  if (::flatbuffers::IsOutRange(e, CityType_NONE, CityType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCityType()[index];
}

enum PkType : int32_t {
  PkType_Safe = 0,
  PkType_Lawful = 1,
  PkType_Conflict = 2,
  PkType_Hostile = 3,
  PkType_Arena = 4,
  PkType_MIN = PkType_Safe,
  PkType_MAX = PkType_Arena
};

inline const PkType (&EnumValuesPkType())[5] {
  static const PkType values[] = {
    PkType_Safe,
    PkType_Lawful,
    PkType_Conflict,
    PkType_Hostile,
    PkType_Arena
  };
  return values;
}

inline const char * const *EnumNamesPkType() {
  static const char * const names[6] = {
    "Safe",
    "Lawful",
    "Conflict",
    "Hostile",
    "Arena",
    nullptr
  };
  return names;
}

inline const char *EnumNamePkType(PkType e) {
  if (::flatbuffers::IsOutRange(e, PkType_Safe, PkType_Arena)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPkType()[index];
}

enum AreaType : int32_t {
  AreaType_City = 0,
  AreaType_Village = 1,
  AreaType_Field = 2,
  AreaType_Instance = 3,
  AreaType_MIN = AreaType_City,
  AreaType_MAX = AreaType_Instance
};

inline const AreaType (&EnumValuesAreaType())[4] {
  static const AreaType values[] = {
    AreaType_City,
    AreaType_Village,
    AreaType_Field,
    AreaType_Instance
  };
  return values;
}

inline const char * const *EnumNamesAreaType() {
  static const char * const names[5] = {
    "City",
    "Village",
    "Field",
    "Instance",
    nullptr
  };
  return names;
}

inline const char *EnumNameAreaType(AreaType e) {
  if (::flatbuffers::IsOutRange(e, AreaType_City, AreaType_Instance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAreaType()[index];
}

enum AttributeType : int32_t {
  AttributeType_None = 0,
  AttributeType_Fire = 1,
  AttributeType_Water = 2,
  AttributeType_Wind = 3,
  AttributeType_Earth = 4,
  AttributeType_Holy = 5,
  AttributeType_Dark = 6,
  AttributeType_MIN = AttributeType_None,
  AttributeType_MAX = AttributeType_Dark
};

inline const AttributeType (&EnumValuesAttributeType())[7] {
  static const AttributeType values[] = {
    AttributeType_None,
    AttributeType_Fire,
    AttributeType_Water,
    AttributeType_Wind,
    AttributeType_Earth,
    AttributeType_Holy,
    AttributeType_Dark
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[8] = {
    "None",
    "Fire",
    "Water",
    "Wind",
    "Earth",
    "Holy",
    "Dark",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType_None, AttributeType_Dark)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum RaceType : int32_t {
  RaceType_Human = 0,
  RaceType_Elf = 1,
  RaceType_Dwarf = 2,
  RaceType_Orc = 3,
  RaceType_Undead = 4,
  RaceType_Dragon = 5,
  RaceType_MIN = RaceType_Human,
  RaceType_MAX = RaceType_Dragon
};

inline const RaceType (&EnumValuesRaceType())[6] {
  static const RaceType values[] = {
    RaceType_Human,
    RaceType_Elf,
    RaceType_Dwarf,
    RaceType_Orc,
    RaceType_Undead,
    RaceType_Dragon
  };
  return values;
}

inline const char * const *EnumNamesRaceType() {
  static const char * const names[7] = {
    "Human",
    "Elf",
    "Dwarf",
    "Orc",
    "Undead",
    "Dragon",
    nullptr
  };
  return names;
}

inline const char *EnumNameRaceType(RaceType e) {
  if (::flatbuffers::IsOutRange(e, RaceType_Human, RaceType_Dragon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRaceType()[index];
}

enum CurrencyType : int32_t {
  CurrencyType_Gold = 0,
  CurrencyType_Ruby = 1,
  CurrencyType_Mileage = 2,
  CurrencyType_Honor = 3,
  CurrencyType_GuildPoint = 4,
  CurrencyType_MIN = CurrencyType_Gold,
  CurrencyType_MAX = CurrencyType_GuildPoint
};

inline const CurrencyType (&EnumValuesCurrencyType())[5] {
  static const CurrencyType values[] = {
    CurrencyType_Gold,
    CurrencyType_Ruby,
    CurrencyType_Mileage,
    CurrencyType_Honor,
    CurrencyType_GuildPoint
  };
  return values;
}

inline const char * const *EnumNamesCurrencyType() {
  static const char * const names[6] = {
    "Gold",
    "Ruby",
    "Mileage",
    "Honor",
    "GuildPoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrencyType(CurrencyType e) {
  if (::flatbuffers::IsOutRange(e, CurrencyType_Gold, CurrencyType_GuildPoint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurrencyType()[index];
}

enum GradeType : int32_t {
  GradeType_Normal = 0,
  GradeType_Magic = 1,
  GradeType_Rare = 2,
  GradeType_Unique = 3,
  GradeType_Epic = 4,
  GradeType_Legendary = 5,
  GradeType_Mythic = 6,
  GradeType_MIN = GradeType_Normal,
  GradeType_MAX = GradeType_Mythic
};

inline const GradeType (&EnumValuesGradeType())[7] {
  static const GradeType values[] = {
    GradeType_Normal,
    GradeType_Magic,
    GradeType_Rare,
    GradeType_Unique,
    GradeType_Epic,
    GradeType_Legendary,
    GradeType_Mythic
  };
  return values;
}

inline const char * const *EnumNamesGradeType() {
  static const char * const names[8] = {
    "Normal",
    "Magic",
    "Rare",
    "Unique",
    "Epic",
    "Legendary",
    "Mythic",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradeType(GradeType e) {
  if (::flatbuffers::IsOutRange(e, GradeType_Normal, GradeType_Mythic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradeType()[index];
}

enum StatType : int32_t {
  StatType_Strength = 0,
  StatType_Agility = 1,
  StatType_Intelligence = 2,
  StatType_Stamina = 3,
  StatType_Dexterity = 4,
  StatType_Wisdom = 5,
  StatType_Luck = 6,
  StatType_Constitution = 7,
  StatType_Spirit = 8,
  StatType_Charisma = 9,
  StatType_Hp = 10,
  StatType_Mp = 11,
  StatType_HpRegen = 12,
  StatType_MpRegen = 13,
  StatType_AttackSpeed = 14,
  StatType_CastSpeed = 15,
  StatType_MoveSpeed = 16,
  StatType_Accuracy = 17,
  StatType_Penetration = 18,
  StatType_MagicPenetration = 19,
  StatType_SkillDamage = 20,
  StatType_BonusDamage = 21,
  StatType_DamageReduction = 22,
  StatType_BossDamage = 23,
  StatType_PhysicalAtk = 24,
  StatType_PhysicalDef = 25,
  StatType_MagicalAtk = 26,
  StatType_MagicalDef = 27,
  StatType_FireDamage = 28,
  StatType_FireReduction = 29,
  StatType_WaterDamage = 30,
  StatType_WaterReduction = 31,
  StatType_WindDamage = 32,
  StatType_WindReduction = 33,
  StatType_EarthDamage = 34,
  StatType_EarthReduction = 35,
  StatType_HolyDamage = 36,
  StatType_HolyReduction = 37,
  StatType_DarkDamage = 38,
  StatType_DarkReduction = 39,
  StatType_CriRate = 40,
  StatType_CriResist = 41,
  StatType_CriDamage = 42,
  StatType_CriReduction = 43,
  StatType_BlockRate = 44,
  StatType_BlockResist = 45,
  StatType_MIN = StatType_Strength,
  StatType_MAX = StatType_BlockResist
};

inline const StatType (&EnumValuesStatType())[46] {
  static const StatType values[] = {
    StatType_Strength,
    StatType_Agility,
    StatType_Intelligence,
    StatType_Stamina,
    StatType_Dexterity,
    StatType_Wisdom,
    StatType_Luck,
    StatType_Constitution,
    StatType_Spirit,
    StatType_Charisma,
    StatType_Hp,
    StatType_Mp,
    StatType_HpRegen,
    StatType_MpRegen,
    StatType_AttackSpeed,
    StatType_CastSpeed,
    StatType_MoveSpeed,
    StatType_Accuracy,
    StatType_Penetration,
    StatType_MagicPenetration,
    StatType_SkillDamage,
    StatType_BonusDamage,
    StatType_DamageReduction,
    StatType_BossDamage,
    StatType_PhysicalAtk,
    StatType_PhysicalDef,
    StatType_MagicalAtk,
    StatType_MagicalDef,
    StatType_FireDamage,
    StatType_FireReduction,
    StatType_WaterDamage,
    StatType_WaterReduction,
    StatType_WindDamage,
    StatType_WindReduction,
    StatType_EarthDamage,
    StatType_EarthReduction,
    StatType_HolyDamage,
    StatType_HolyReduction,
    StatType_DarkDamage,
    StatType_DarkReduction,
    StatType_CriRate,
    StatType_CriResist,
    StatType_CriDamage,
    StatType_CriReduction,
    StatType_BlockRate,
    StatType_BlockResist
  };
  return values;
}

inline const char * const *EnumNamesStatType() {
  static const char * const names[47] = {
    "Strength",
    "Agility",
    "Intelligence",
    "Stamina",
    "Dexterity",
    "Wisdom",
    "Luck",
    "Constitution",
    "Spirit",
    "Charisma",
    "Hp",
    "Mp",
    "HpRegen",
    "MpRegen",
    "AttackSpeed",
    "CastSpeed",
    "MoveSpeed",
    "Accuracy",
    "Penetration",
    "MagicPenetration",
    "SkillDamage",
    "BonusDamage",
    "DamageReduction",
    "BossDamage",
    "PhysicalAtk",
    "PhysicalDef",
    "MagicalAtk",
    "MagicalDef",
    "FireDamage",
    "FireReduction",
    "WaterDamage",
    "WaterReduction",
    "WindDamage",
    "WindReduction",
    "EarthDamage",
    "EarthReduction",
    "HolyDamage",
    "HolyReduction",
    "DarkDamage",
    "DarkReduction",
    "CriRate",
    "CriResist",
    "CriDamage",
    "CriReduction",
    "BlockRate",
    "BlockResist",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatType(StatType e) {
  if (::flatbuffers::IsOutRange(e, StatType_Strength, StatType_BlockResist)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatType()[index];
}

enum AbilityType : int32_t {
  AbilityType_Stun = 0,
  AbilityType_Knockback = 1,
  AbilityType_Slow = 2,
  AbilityType_Provoke = 3,
  AbilityType_Silence = 4,
  AbilityType_Blessing = 5,
  AbilityType_DoubleHitChance = 6,
  AbilityType_IgnoreShield = 7,
  AbilityType_LifeSteal = 8,
  AbilityType_Shield = 9,
  AbilityType_HealingUp = 10,
  AbilityType_CoolTimeDown = 11,
  AbilityType_Burn = 12,
  AbilityType_Curse = 13,
  AbilityType_Immortal = 14,
  AbilityType_MIN = AbilityType_Stun,
  AbilityType_MAX = AbilityType_Immortal
};

inline const AbilityType (&EnumValuesAbilityType())[15] {
  static const AbilityType values[] = {
    AbilityType_Stun,
    AbilityType_Knockback,
    AbilityType_Slow,
    AbilityType_Provoke,
    AbilityType_Silence,
    AbilityType_Blessing,
    AbilityType_DoubleHitChance,
    AbilityType_IgnoreShield,
    AbilityType_LifeSteal,
    AbilityType_Shield,
    AbilityType_HealingUp,
    AbilityType_CoolTimeDown,
    AbilityType_Burn,
    AbilityType_Curse,
    AbilityType_Immortal
  };
  return values;
}

inline const char * const *EnumNamesAbilityType() {
  static const char * const names[16] = {
    "Stun",
    "Knockback",
    "Slow",
    "Provoke",
    "Silence",
    "Blessing",
    "DoubleHitChance",
    "IgnoreShield",
    "LifeSteal",
    "Shield",
    "HealingUp",
    "CoolTimeDown",
    "Burn",
    "Curse",
    "Immortal",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityType(AbilityType e) {
  if (::flatbuffers::IsOutRange(e, AbilityType_Stun, AbilityType_Immortal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityType()[index];
}

enum TargetType : int32_t {
  TargetType_Caster = 0,
  TargetType_Enemy = 1,
  TargetType_Party = 2,
  TargetType_Guild = 3,
  TargetType_Ally = 4,
  TargetType_All = 5,
  TargetType_MIN = TargetType_Caster,
  TargetType_MAX = TargetType_All
};

inline const TargetType (&EnumValuesTargetType())[6] {
  static const TargetType values[] = {
    TargetType_Caster,
    TargetType_Enemy,
    TargetType_Party,
    TargetType_Guild,
    TargetType_Ally,
    TargetType_All
  };
  return values;
}

inline const char * const *EnumNamesTargetType() {
  static const char * const names[7] = {
    "Caster",
    "Enemy",
    "Party",
    "Guild",
    "Ally",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetType(TargetType e) {
  if (::flatbuffers::IsOutRange(e, TargetType_Caster, TargetType_All)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetType()[index];
}

enum TargetingType : int32_t {
  TargetingType_Self = 0,
  TargetingType_Unit = 1,
  TargetingType_Ground = 2,
  TargetingType_MIN = TargetingType_Self,
  TargetingType_MAX = TargetingType_Ground
};

inline const TargetingType (&EnumValuesTargetingType())[3] {
  static const TargetingType values[] = {
    TargetingType_Self,
    TargetingType_Unit,
    TargetingType_Ground
  };
  return values;
}

inline const char * const *EnumNamesTargetingType() {
  static const char * const names[4] = {
    "Self",
    "Unit",
    "Ground",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetingType(TargetingType e) {
  if (::flatbuffers::IsOutRange(e, TargetingType_Self, TargetingType_Ground)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetingType()[index];
}

enum CostType : int32_t {
  CostType_Gold = 0,
  CostType_Hp = 1,
  CostType_Mp = 2,
  CostType_MIN = CostType_Gold,
  CostType_MAX = CostType_Mp
};

inline const CostType (&EnumValuesCostType())[3] {
  static const CostType values[] = {
    CostType_Gold,
    CostType_Hp,
    CostType_Mp
  };
  return values;
}

inline const char * const *EnumNamesCostType() {
  static const char * const names[4] = {
    "Gold",
    "Hp",
    "Mp",
    nullptr
  };
  return names;
}

inline const char *EnumNameCostType(CostType e) {
  if (::flatbuffers::IsOutRange(e, CostType_Gold, CostType_Mp)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCostType()[index];
}

enum ItemReason : int32_t {
  ItemReason_AddDrop = 0,
  ItemReason_SubUse = 1,
  ItemReason_MIN = ItemReason_AddDrop,
  ItemReason_MAX = ItemReason_SubUse
};

inline const ItemReason (&EnumValuesItemReason())[2] {
  static const ItemReason values[] = {
    ItemReason_AddDrop,
    ItemReason_SubUse
  };
  return values;
}

inline const char * const *EnumNamesItemReason() {
  static const char * const names[3] = {
    "AddDrop",
    "SubUse",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemReason(ItemReason e) {
  if (::flatbuffers::IsOutRange(e, ItemReason_AddDrop, ItemReason_SubUse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemReason()[index];
}

enum MoveType : int32_t {
  MoveType_Walk = 0,
  MoveType_Teleport = 1,
  MoveType_MIN = MoveType_Walk,
  MoveType_MAX = MoveType_Teleport
};

inline const MoveType (&EnumValuesMoveType())[2] {
  static const MoveType values[] = {
    MoveType_Walk,
    MoveType_Teleport
  };
  return values;
}

inline const char * const *EnumNamesMoveType() {
  static const char * const names[3] = {
    "Walk",
    "Teleport",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoveType(MoveType e) {
  if (::flatbuffers::IsOutRange(e, MoveType_Walk, MoveType_Teleport)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoveType()[index];
}

enum JobType : int32_t {
  JobType_Warrior = 0,
  JobType_Berserker = 1,
  JobType_Knight = 2,
  JobType_Paladin = 3,
  JobType_DarkKnight = 4,
  JobType_Priest = 5,
  JobType_Bishop = 6,
  JobType_SoulKeeper = 7,
  JobType_Necromancer = 8,
  JobType_Wizard = 9,
  JobType_Pyromancer = 10,
  JobType_Cryomancer = 11,
  JobType_Stormcaller = 12,
  JobType_Geomancer = 13,
  JobType_Ranger = 14,
  JobType_Hunter = 15,
  JobType_Assassin = 16,
  JobType_ShadowBlade = 17,
  JobType_Druid = 18,
  JobType_Summoner = 19,
  JobType_Bard = 20,
  JobType_Alchemist = 21,
  JobType_MIN = JobType_Warrior,
  JobType_MAX = JobType_Alchemist
};

inline const JobType (&EnumValuesJobType())[22] {
  static const JobType values[] = {
    JobType_Warrior,
    JobType_Berserker,
    JobType_Knight,
    JobType_Paladin,
    JobType_DarkKnight,
    JobType_Priest,
    JobType_Bishop,
    JobType_SoulKeeper,
    JobType_Necromancer,
    JobType_Wizard,
    JobType_Pyromancer,
    JobType_Cryomancer,
    JobType_Stormcaller,
    JobType_Geomancer,
    JobType_Ranger,
    JobType_Hunter,
    JobType_Assassin,
    JobType_ShadowBlade,
    JobType_Druid,
    JobType_Summoner,
    JobType_Bard,
    JobType_Alchemist
  };
  return values;
}

inline const char * const *EnumNamesJobType() {
  static const char * const names[23] = {
    "Warrior",
    "Berserker",
    "Knight",
    "Paladin",
    "DarkKnight",
    "Priest",
    "Bishop",
    "SoulKeeper",
    "Necromancer",
    "Wizard",
    "Pyromancer",
    "Cryomancer",
    "Stormcaller",
    "Geomancer",
    "Ranger",
    "Hunter",
    "Assassin",
    "ShadowBlade",
    "Druid",
    "Summoner",
    "Bard",
    "Alchemist",
    nullptr
  };
  return names;
}

inline const char *EnumNameJobType(JobType e) {
  if (::flatbuffers::IsOutRange(e, JobType_Warrior, JobType_Alchemist)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJobType()[index];
}

enum ItemType : int32_t {
  ItemType_Weapon = 0,
  ItemType_Armor = 1,
  ItemType_Accessory = 2,
  ItemType_Consumable = 3,
  ItemType_Material = 4,
  ItemType_QuestItem = 5,
  ItemType_Skillbook = 6,
  ItemType_Blueprint = 7,
  ItemType_Relic = 8,
  ItemType_EnchantStone = 9,
  ItemType_Mount = 10,
  ItemType_Pet = 11,
  ItemType_Misc = 12,
  ItemType_MIN = ItemType_Weapon,
  ItemType_MAX = ItemType_Misc
};

inline const ItemType (&EnumValuesItemType())[13] {
  static const ItemType values[] = {
    ItemType_Weapon,
    ItemType_Armor,
    ItemType_Accessory,
    ItemType_Consumable,
    ItemType_Material,
    ItemType_QuestItem,
    ItemType_Skillbook,
    ItemType_Blueprint,
    ItemType_Relic,
    ItemType_EnchantStone,
    ItemType_Mount,
    ItemType_Pet,
    ItemType_Misc
  };
  return values;
}

inline const char * const *EnumNamesItemType() {
  static const char * const names[14] = {
    "Weapon",
    "Armor",
    "Accessory",
    "Consumable",
    "Material",
    "QuestItem",
    "Skillbook",
    "Blueprint",
    "Relic",
    "EnchantStone",
    "Mount",
    "Pet",
    "Misc",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemType(ItemType e) {
  if (::flatbuffers::IsOutRange(e, ItemType_Weapon, ItemType_Misc)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemType()[index];
}

enum WeaponType : int32_t {
  WeaponType_Sword = 0,
  WeaponType_TwoHandSword = 1,
  WeaponType_Axe = 2,
  WeaponType_TwoHandAxe = 3,
  WeaponType_Mace = 4,
  WeaponType_TwoHandMace = 5,
  WeaponType_Spear = 6,
  WeaponType_Dagger = 7,
  WeaponType_Katana = 8,
  WeaponType_Scythe = 9,
  WeaponType_Staff = 10,
  WeaponType_Wand = 11,
  WeaponType_Tome = 12,
  WeaponType_Bow = 13,
  WeaponType_Crossbow = 14,
  WeaponType_Shield = 15,
  WeaponType_MIN = WeaponType_Sword,
  WeaponType_MAX = WeaponType_Shield
};

inline const WeaponType (&EnumValuesWeaponType())[16] {
  static const WeaponType values[] = {
    WeaponType_Sword,
    WeaponType_TwoHandSword,
    WeaponType_Axe,
    WeaponType_TwoHandAxe,
    WeaponType_Mace,
    WeaponType_TwoHandMace,
    WeaponType_Spear,
    WeaponType_Dagger,
    WeaponType_Katana,
    WeaponType_Scythe,
    WeaponType_Staff,
    WeaponType_Wand,
    WeaponType_Tome,
    WeaponType_Bow,
    WeaponType_Crossbow,
    WeaponType_Shield
  };
  return values;
}

inline const char * const *EnumNamesWeaponType() {
  static const char * const names[17] = {
    "Sword",
    "TwoHandSword",
    "Axe",
    "TwoHandAxe",
    "Mace",
    "TwoHandMace",
    "Spear",
    "Dagger",
    "Katana",
    "Scythe",
    "Staff",
    "Wand",
    "Tome",
    "Bow",
    "Crossbow",
    "Shield",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeaponType(WeaponType e) {
  if (::flatbuffers::IsOutRange(e, WeaponType_Sword, WeaponType_Shield)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeaponType()[index];
}

enum ArmorType : int32_t {
  ArmorType_HeavyArmor = 0,
  ArmorType_MediumArmor = 1,
  ArmorType_LightArmor = 2,
  ArmorType_Robe = 3,
  ArmorType_Cloth = 4,
  ArmorType_MIN = ArmorType_HeavyArmor,
  ArmorType_MAX = ArmorType_Cloth
};

inline const ArmorType (&EnumValuesArmorType())[5] {
  static const ArmorType values[] = {
    ArmorType_HeavyArmor,
    ArmorType_MediumArmor,
    ArmorType_LightArmor,
    ArmorType_Robe,
    ArmorType_Cloth
  };
  return values;
}

inline const char * const *EnumNamesArmorType() {
  static const char * const names[6] = {
    "HeavyArmor",
    "MediumArmor",
    "LightArmor",
    "Robe",
    "Cloth",
    nullptr
  };
  return names;
}

inline const char *EnumNameArmorType(ArmorType e) {
  if (::flatbuffers::IsOutRange(e, ArmorType_HeavyArmor, ArmorType_Cloth)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArmorType()[index];
}

enum EquipSlot : int32_t {
  EquipSlot_Helm = 0,
  EquipSlot_Chest = 1,
  EquipSlot_Legs = 2,
  EquipSlot_Gloves = 3,
  EquipSlot_Boots = 4,
  EquipSlot_Cloak = 5,
  EquipSlot_Weapon = 6,
  EquipSlot_OffHand = 7,
  EquipSlot_Ring1 = 8,
  EquipSlot_Ring2 = 9,
  EquipSlot_Necklace = 10,
  EquipSlot_Earring = 11,
  EquipSlot_Belt = 12,
  EquipSlot_Relic = 13,
  EquipSlot_MIN = EquipSlot_Helm,
  EquipSlot_MAX = EquipSlot_Relic
};

inline const EquipSlot (&EnumValuesEquipSlot())[14] {
  static const EquipSlot values[] = {
    EquipSlot_Helm,
    EquipSlot_Chest,
    EquipSlot_Legs,
    EquipSlot_Gloves,
    EquipSlot_Boots,
    EquipSlot_Cloak,
    EquipSlot_Weapon,
    EquipSlot_OffHand,
    EquipSlot_Ring1,
    EquipSlot_Ring2,
    EquipSlot_Necklace,
    EquipSlot_Earring,
    EquipSlot_Belt,
    EquipSlot_Relic
  };
  return values;
}

inline const char * const *EnumNamesEquipSlot() {
  static const char * const names[15] = {
    "Helm",
    "Chest",
    "Legs",
    "Gloves",
    "Boots",
    "Cloak",
    "Weapon",
    "OffHand",
    "Ring1",
    "Ring2",
    "Necklace",
    "Earring",
    "Belt",
    "Relic",
    nullptr
  };
  return names;
}

inline const char *EnumNameEquipSlot(EquipSlot e) {
  if (::flatbuffers::IsOutRange(e, EquipSlot_Helm, EquipSlot_Relic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEquipSlot()[index];
}

enum SkillType : int32_t {
  SkillType_Active = 0,
  SkillType_Passive = 1,
  SkillType_Ultimate = 2,
  SkillType_Toggle = 3,
  SkillType_Reaction = 4,
  SkillType_MIN = SkillType_Active,
  SkillType_MAX = SkillType_Reaction
};

inline const SkillType (&EnumValuesSkillType())[5] {
  static const SkillType values[] = {
    SkillType_Active,
    SkillType_Passive,
    SkillType_Ultimate,
    SkillType_Toggle,
    SkillType_Reaction
  };
  return values;
}

inline const char * const *EnumNamesSkillType() {
  static const char * const names[6] = {
    "Active",
    "Passive",
    "Ultimate",
    "Toggle",
    "Reaction",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillType(SkillType e) {
  if (::flatbuffers::IsOutRange(e, SkillType_Active, SkillType_Reaction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillType()[index];
}

enum SkillCategory : int32_t {
  SkillCategory_MeleeAttack = 0,
  SkillCategory_RangedAttack = 1,
  SkillCategory_MagicAttack = 2,
  SkillCategory_ElementalAttack = 3,
  SkillCategory_Heal = 4,
  SkillCategory_Buff = 5,
  SkillCategory_Debuff = 6,
  SkillCategory_Summon = 7,
  SkillCategory_Movement = 8,
  SkillCategory_Defense = 9,
  SkillCategory_Support = 10,
  SkillCategory_MIN = SkillCategory_MeleeAttack,
  SkillCategory_MAX = SkillCategory_Support
};

inline const SkillCategory (&EnumValuesSkillCategory())[11] {
  static const SkillCategory values[] = {
    SkillCategory_MeleeAttack,
    SkillCategory_RangedAttack,
    SkillCategory_MagicAttack,
    SkillCategory_ElementalAttack,
    SkillCategory_Heal,
    SkillCategory_Buff,
    SkillCategory_Debuff,
    SkillCategory_Summon,
    SkillCategory_Movement,
    SkillCategory_Defense,
    SkillCategory_Support
  };
  return values;
}

inline const char * const *EnumNamesSkillCategory() {
  static const char * const names[12] = {
    "MeleeAttack",
    "RangedAttack",
    "MagicAttack",
    "ElementalAttack",
    "Heal",
    "Buff",
    "Debuff",
    "Summon",
    "Movement",
    "Defense",
    "Support",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillCategory(SkillCategory e) {
  if (::flatbuffers::IsOutRange(e, SkillCategory_MeleeAttack, SkillCategory_Support)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillCategory()[index];
}

enum DamageType : int32_t {
  DamageType_Physical = 0,
  DamageType_Magical = 1,
  DamageType_True = 2,
  DamageType_Holy = 3,
  DamageType_Dark = 4,
  DamageType_Fire = 5,
  DamageType_Ice = 6,
  DamageType_Lightning = 7,
  DamageType_Earth = 8,
  DamageType_Bleed = 9,
  DamageType_Poison = 10,
  DamageType_MIN = DamageType_Physical,
  DamageType_MAX = DamageType_Poison
};

inline const DamageType (&EnumValuesDamageType())[11] {
  static const DamageType values[] = {
    DamageType_Physical,
    DamageType_Magical,
    DamageType_True,
    DamageType_Holy,
    DamageType_Dark,
    DamageType_Fire,
    DamageType_Ice,
    DamageType_Lightning,
    DamageType_Earth,
    DamageType_Bleed,
    DamageType_Poison
  };
  return values;
}

inline const char * const *EnumNamesDamageType() {
  static const char * const names[12] = {
    "Physical",
    "Magical",
    "True",
    "Holy",
    "Dark",
    "Fire",
    "Ice",
    "Lightning",
    "Earth",
    "Bleed",
    "Poison",
    nullptr
  };
  return names;
}

inline const char *EnumNameDamageType(DamageType e) {
  if (::flatbuffers::IsOutRange(e, DamageType_Physical, DamageType_Poison)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDamageType()[index];
}

enum MonsterType : int32_t {
  MonsterType_Beast = 0,
  MonsterType_Undead = 1,
  MonsterType_Demon = 2,
  MonsterType_Dragon = 3,
  MonsterType_Elemental = 4,
  MonsterType_HolyBeing = 5,
  MonsterType_DarkBeing = 6,
  MonsterType_Human = 7,
  MonsterType_Plant = 8,
  MonsterType_Construct = 9,
  MonsterType_MIN = MonsterType_Beast,
  MonsterType_MAX = MonsterType_Construct
};

inline const MonsterType (&EnumValuesMonsterType())[10] {
  static const MonsterType values[] = {
    MonsterType_Beast,
    MonsterType_Undead,
    MonsterType_Demon,
    MonsterType_Dragon,
    MonsterType_Elemental,
    MonsterType_HolyBeing,
    MonsterType_DarkBeing,
    MonsterType_Human,
    MonsterType_Plant,
    MonsterType_Construct
  };
  return values;
}

inline const char * const *EnumNamesMonsterType() {
  static const char * const names[11] = {
    "Beast",
    "Undead",
    "Demon",
    "Dragon",
    "Elemental",
    "HolyBeing",
    "DarkBeing",
    "Human",
    "Plant",
    "Construct",
    nullptr
  };
  return names;
}

inline const char *EnumNameMonsterType(MonsterType e) {
  if (::flatbuffers::IsOutRange(e, MonsterType_Beast, MonsterType_Construct)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMonsterType()[index];
}

enum StatusEffectType : int32_t {
  StatusEffectType_Bleed = 0,
  StatusEffectType_Fracture = 1,
  StatusEffectType_Root = 2,
  StatusEffectType_Poison = 3,
  StatusEffectType_Freeze = 4,
  StatusEffectType_Electrify = 5,
  StatusEffectType_Ignite = 6,
  StatusEffectType_Petrify = 7,
  StatusEffectType_Blind = 8,
  StatusEffectType_Reveal = 9,
  StatusEffectType_HolyMark = 10,
  StatusEffectType_Curse = 11,
  StatusEffectType_Fear = 12,
  StatusEffectType_Decay = 13,
  StatusEffectType_DarkMark = 14,
  StatusEffectType_Stun = 15,
  StatusEffectType_Sleep = 16,
  StatusEffectType_Silence = 17,
  StatusEffectType_Slow = 18,
  StatusEffectType_Knockback = 19,
  StatusEffectType_MIN = StatusEffectType_Bleed,
  StatusEffectType_MAX = StatusEffectType_Knockback
};

inline const StatusEffectType (&EnumValuesStatusEffectType())[20] {
  static const StatusEffectType values[] = {
    StatusEffectType_Bleed,
    StatusEffectType_Fracture,
    StatusEffectType_Root,
    StatusEffectType_Poison,
    StatusEffectType_Freeze,
    StatusEffectType_Electrify,
    StatusEffectType_Ignite,
    StatusEffectType_Petrify,
    StatusEffectType_Blind,
    StatusEffectType_Reveal,
    StatusEffectType_HolyMark,
    StatusEffectType_Curse,
    StatusEffectType_Fear,
    StatusEffectType_Decay,
    StatusEffectType_DarkMark,
    StatusEffectType_Stun,
    StatusEffectType_Sleep,
    StatusEffectType_Silence,
    StatusEffectType_Slow,
    StatusEffectType_Knockback
  };
  return values;
}

inline const char * const *EnumNamesStatusEffectType() {
  static const char * const names[21] = {
    "Bleed",
    "Fracture",
    "Root",
    "Poison",
    "Freeze",
    "Electrify",
    "Ignite",
    "Petrify",
    "Blind",
    "Reveal",
    "HolyMark",
    "Curse",
    "Fear",
    "Decay",
    "DarkMark",
    "Stun",
    "Sleep",
    "Silence",
    "Slow",
    "Knockback",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusEffectType(StatusEffectType e) {
  if (::flatbuffers::IsOutRange(e, StatusEffectType_Bleed, StatusEffectType_Knockback)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusEffectType()[index];
}

enum ZoneAttributeType : int32_t {
  ZoneAttributeType_Neutral = 0,
  ZoneAttributeType_Holy = 1,
  ZoneAttributeType_Dark = 2,
  ZoneAttributeType_Fire = 3,
  ZoneAttributeType_Ice = 4,
  ZoneAttributeType_Lightning = 5,
  ZoneAttributeType_Earth = 6,
  ZoneAttributeType_Cursed = 7,
  ZoneAttributeType_Sacred = 8,
  ZoneAttributeType_MIN = ZoneAttributeType_Neutral,
  ZoneAttributeType_MAX = ZoneAttributeType_Sacred
};

inline const ZoneAttributeType (&EnumValuesZoneAttributeType())[9] {
  static const ZoneAttributeType values[] = {
    ZoneAttributeType_Neutral,
    ZoneAttributeType_Holy,
    ZoneAttributeType_Dark,
    ZoneAttributeType_Fire,
    ZoneAttributeType_Ice,
    ZoneAttributeType_Lightning,
    ZoneAttributeType_Earth,
    ZoneAttributeType_Cursed,
    ZoneAttributeType_Sacred
  };
  return values;
}

inline const char * const *EnumNamesZoneAttributeType() {
  static const char * const names[10] = {
    "Neutral",
    "Holy",
    "Dark",
    "Fire",
    "Ice",
    "Lightning",
    "Earth",
    "Cursed",
    "Sacred",
    nullptr
  };
  return names;
}

inline const char *EnumNameZoneAttributeType(ZoneAttributeType e) {
  if (::flatbuffers::IsOutRange(e, ZoneAttributeType_Neutral, ZoneAttributeType_Sacred)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesZoneAttributeType()[index];
}

enum MapType : int32_t {
  MapType_Town = 0,
  MapType_Field = 1,
  MapType_Dungeon = 2,
  MapType_Raid = 3,
  MapType_PvP = 4,
  MapType_Instance = 5,
  MapType_MIN = MapType_Town,
  MapType_MAX = MapType_Instance
};

inline const MapType (&EnumValuesMapType())[6] {
  static const MapType values[] = {
    MapType_Town,
    MapType_Field,
    MapType_Dungeon,
    MapType_Raid,
    MapType_PvP,
    MapType_Instance
  };
  return values;
}

inline const char * const *EnumNamesMapType() {
  static const char * const names[7] = {
    "Town",
    "Field",
    "Dungeon",
    "Raid",
    "PvP",
    "Instance",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  if (::flatbuffers::IsOutRange(e, MapType_Town, MapType_Instance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMapType()[index];
}

enum DungeonType : int32_t {
  DungeonType_Normal = 0,
  DungeonType_Solo = 1,
  DungeonType_Elite = 2,
  DungeonType_Hard = 3,
  DungeonType_Challenge = 4,
  DungeonType_Raid = 5,
  DungeonType_Special = 6,
  DungeonType_MIN = DungeonType_Normal,
  DungeonType_MAX = DungeonType_Special
};

inline const DungeonType (&EnumValuesDungeonType())[7] {
  static const DungeonType values[] = {
    DungeonType_Normal,
    DungeonType_Solo,
    DungeonType_Elite,
    DungeonType_Hard,
    DungeonType_Challenge,
    DungeonType_Raid,
    DungeonType_Special
  };
  return values;
}

inline const char * const *EnumNamesDungeonType() {
  static const char * const names[8] = {
    "Normal",
    "Solo",
    "Elite",
    "Hard",
    "Challenge",
    "Raid",
    "Special",
    nullptr
  };
  return names;
}

inline const char *EnumNameDungeonType(DungeonType e) {
  if (::flatbuffers::IsOutRange(e, DungeonType_Normal, DungeonType_Special)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDungeonType()[index];
}

enum QuestType : int32_t {
  QuestType_Main = 0,
  QuestType_Sub = 1,
  QuestType_Daily = 2,
  QuestType_Weekly = 3,
  QuestType_Guild = 4,
  QuestType_Bounty = 5,
  QuestType_ClassQuest = 6,
  QuestType_Repeatable = 7,
  QuestType_MIN = QuestType_Main,
  QuestType_MAX = QuestType_Repeatable
};

inline const QuestType (&EnumValuesQuestType())[8] {
  static const QuestType values[] = {
    QuestType_Main,
    QuestType_Sub,
    QuestType_Daily,
    QuestType_Weekly,
    QuestType_Guild,
    QuestType_Bounty,
    QuestType_ClassQuest,
    QuestType_Repeatable
  };
  return values;
}

inline const char * const *EnumNamesQuestType() {
  static const char * const names[9] = {
    "Main",
    "Sub",
    "Daily",
    "Weekly",
    "Guild",
    "Bounty",
    "ClassQuest",
    "Repeatable",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuestType(QuestType e) {
  if (::flatbuffers::IsOutRange(e, QuestType_Main, QuestType_Repeatable)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuestType()[index];
}

enum NPCType : int32_t {
  NPCType_Merchant = 0,
  NPCType_QuestGiver = 1,
  NPCType_Guard = 2,
  NPCType_Blacksmith = 3,
  NPCType_Enchanter = 4,
  NPCType_Alchemist = 5,
  NPCType_Trainer = 6,
  NPCType_GuildMaster = 7,
  NPCType_AuctionClerk = 8,
  NPCType_Banker = 9,
  NPCType_Teleporter = 10,
  NPCType_MIN = NPCType_Merchant,
  NPCType_MAX = NPCType_Teleporter
};

inline const NPCType (&EnumValuesNPCType())[11] {
  static const NPCType values[] = {
    NPCType_Merchant,
    NPCType_QuestGiver,
    NPCType_Guard,
    NPCType_Blacksmith,
    NPCType_Enchanter,
    NPCType_Alchemist,
    NPCType_Trainer,
    NPCType_GuildMaster,
    NPCType_AuctionClerk,
    NPCType_Banker,
    NPCType_Teleporter
  };
  return values;
}

inline const char * const *EnumNamesNPCType() {
  static const char * const names[12] = {
    "Merchant",
    "QuestGiver",
    "Guard",
    "Blacksmith",
    "Enchanter",
    "Alchemist",
    "Trainer",
    "GuildMaster",
    "AuctionClerk",
    "Banker",
    "Teleporter",
    nullptr
  };
  return names;
}

inline const char *EnumNameNPCType(NPCType e) {
  if (::flatbuffers::IsOutRange(e, NPCType_Merchant, NPCType_Teleporter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNPCType()[index];
}

enum CraftType : int32_t {
  CraftType_Blacksmithing = 0,
  CraftType_Tailoring = 1,
  CraftType_Leatherwork = 2,
  CraftType_Alchemy = 3,
  CraftType_Cooking = 4,
  CraftType_Enchanting = 5,
  CraftType_Jeweling = 6,
  CraftType_Inscription = 7,
  CraftType_MIN = CraftType_Blacksmithing,
  CraftType_MAX = CraftType_Inscription
};

inline const CraftType (&EnumValuesCraftType())[8] {
  static const CraftType values[] = {
    CraftType_Blacksmithing,
    CraftType_Tailoring,
    CraftType_Leatherwork,
    CraftType_Alchemy,
    CraftType_Cooking,
    CraftType_Enchanting,
    CraftType_Jeweling,
    CraftType_Inscription
  };
  return values;
}

inline const char * const *EnumNamesCraftType() {
  static const char * const names[9] = {
    "Blacksmithing",
    "Tailoring",
    "Leatherwork",
    "Alchemy",
    "Cooking",
    "Enchanting",
    "Jeweling",
    "Inscription",
    nullptr
  };
  return names;
}

inline const char *EnumNameCraftType(CraftType e) {
  if (::flatbuffers::IsOutRange(e, CraftType_Blacksmithing, CraftType_Inscription)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCraftType()[index];
}

}  // namespace makga

#endif  // FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
