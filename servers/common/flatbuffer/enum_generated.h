// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
#define FLATBUFFERS_GENERATED_ENUM_MAKGA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "version_generated.h"

namespace makga {

enum ServerType : int32_t {
  ServerType_Billing = 0,
  ServerType_Login = 1,
  ServerType_World = 2,
  ServerType_Community = 3,
  ServerType_DBAgent = 4,
  ServerType_Game = 5,
  ServerType_Instance = 6,
  ServerType_Web = 7,
  ServerType_Log = 8,
  ServerType_MIN = ServerType_Billing,
  ServerType_MAX = ServerType_Log
};

inline const ServerType (&EnumValuesServerType())[9] {
  static const ServerType values[] = {
    ServerType_Billing,
    ServerType_Login,
    ServerType_World,
    ServerType_Community,
    ServerType_DBAgent,
    ServerType_Game,
    ServerType_Instance,
    ServerType_Web,
    ServerType_Log
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[10] = {
    "Billing",
    "Login",
    "World",
    "Community",
    "DBAgent",
    "Game",
    "Instance",
    "Web",
    "Log",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (::flatbuffers::IsOutRange(e, ServerType_Billing, ServerType_Log)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum DatabaseType : int32_t {
  DatabaseType_NONE = 0,
  DatabaseType_MIN = DatabaseType_NONE,
  DatabaseType_MAX = DatabaseType_NONE
};

inline const DatabaseType (&EnumValuesDatabaseType())[1] {
  static const DatabaseType values[] = {
    DatabaseType_NONE
  };
  return values;
}

inline const char * const *EnumNamesDatabaseType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatabaseType(DatabaseType e) {
  if (::flatbuffers::IsOutRange(e, DatabaseType_NONE, DatabaseType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatabaseType()[index];
}

enum RedisType : int32_t {
  RedisType_NONE = 0,
  RedisType_MIN = RedisType_NONE,
  RedisType_MAX = RedisType_NONE
};

inline const RedisType (&EnumValuesRedisType())[1] {
  static const RedisType values[] = {
    RedisType_NONE
  };
  return values;
}

inline const char * const *EnumNamesRedisType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedisType(RedisType e) {
  if (::flatbuffers::IsOutRange(e, RedisType_NONE, RedisType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRedisType()[index];
}

enum AccountType : int32_t {
  AccountType_NONE = 0,
  AccountType_MIN = AccountType_NONE,
  AccountType_MAX = AccountType_NONE
};

inline const AccountType (&EnumValuesAccountType())[1] {
  static const AccountType values[] = {
    AccountType_NONE
  };
  return values;
}

inline const char * const *EnumNamesAccountType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountType(AccountType e) {
  if (::flatbuffers::IsOutRange(e, AccountType_NONE, AccountType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccountType()[index];
}

enum AIType : int32_t {
  AIType_Aggressive = 0,
  AIType_NonAggressive = 1,
  AIType_Coward = 2,
  AIType_FieldBoss = 3,
  AIType_InstanceBoss = 4,
  AIType_Character = 5,
  AIType_Sandbag = 6,
  AIType_MIN = AIType_Aggressive,
  AIType_MAX = AIType_Sandbag
};

inline const AIType (&EnumValuesAIType())[7] {
  static const AIType values[] = {
    AIType_Aggressive,
    AIType_NonAggressive,
    AIType_Coward,
    AIType_FieldBoss,
    AIType_InstanceBoss,
    AIType_Character,
    AIType_Sandbag
  };
  return values;
}

inline const char * const *EnumNamesAIType() {
  static const char * const names[8] = {
    "Aggressive",
    "NonAggressive",
    "Coward",
    "FieldBoss",
    "InstanceBoss",
    "Character",
    "Sandbag",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIType(AIType e) {
  if (::flatbuffers::IsOutRange(e, AIType_Aggressive, AIType_Sandbag)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIType()[index];
}

enum ActorType : int32_t {
  ActorType_None = 0,
  ActorType_Character = 1,
  ActorType_Monster = 2,
  ActorType_Gadget = 3,
  ActorType_Object = 4,
  ActorType_MIN = ActorType_None,
  ActorType_MAX = ActorType_Object
};

inline const ActorType (&EnumValuesActorType())[5] {
  static const ActorType values[] = {
    ActorType_None,
    ActorType_Character,
    ActorType_Monster,
    ActorType_Gadget,
    ActorType_Object
  };
  return values;
}

inline const char * const *EnumNamesActorType() {
  static const char * const names[6] = {
    "None",
    "Character",
    "Monster",
    "Gadget",
    "Object",
    nullptr
  };
  return names;
}

inline const char *EnumNameActorType(ActorType e) {
  if (::flatbuffers::IsOutRange(e, ActorType_None, ActorType_Object)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActorType()[index];
}

enum CityType : int32_t {
  CityType_NONE = 0,
  CityType_MIN = CityType_NONE,
  CityType_MAX = CityType_NONE
};

inline const CityType (&EnumValuesCityType())[1] {
  static const CityType values[] = {
    CityType_NONE
  };
  return values;
}

inline const char * const *EnumNamesCityType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCityType(CityType e) {
  if (::flatbuffers::IsOutRange(e, CityType_NONE, CityType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCityType()[index];
}

enum PkType : int32_t {
  PkType_Safe = 0,
  PkType_Lawful = 1,
  PkType_Conflict = 2,
  PkType_Hostile = 3,
  PkType_Arena = 4,
  PkType_MIN = PkType_Safe,
  PkType_MAX = PkType_Arena
};

inline const PkType (&EnumValuesPkType())[5] {
  static const PkType values[] = {
    PkType_Safe,
    PkType_Lawful,
    PkType_Conflict,
    PkType_Hostile,
    PkType_Arena
  };
  return values;
}

inline const char * const *EnumNamesPkType() {
  static const char * const names[6] = {
    "Safe",
    "Lawful",
    "Conflict",
    "Hostile",
    "Arena",
    nullptr
  };
  return names;
}

inline const char *EnumNamePkType(PkType e) {
  if (::flatbuffers::IsOutRange(e, PkType_Safe, PkType_Arena)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPkType()[index];
}

enum AreaType : int32_t {
  AreaType_City = 0,
  AreaType_Village = 1,
  AreaType_Field = 2,
  AreaType_Instance = 3,
  AreaType_MIN = AreaType_City,
  AreaType_MAX = AreaType_Instance
};

inline const AreaType (&EnumValuesAreaType())[4] {
  static const AreaType values[] = {
    AreaType_City,
    AreaType_Village,
    AreaType_Field,
    AreaType_Instance
  };
  return values;
}

inline const char * const *EnumNamesAreaType() {
  static const char * const names[5] = {
    "City",
    "Village",
    "Field",
    "Instance",
    nullptr
  };
  return names;
}

inline const char *EnumNameAreaType(AreaType e) {
  if (::flatbuffers::IsOutRange(e, AreaType_City, AreaType_Instance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAreaType()[index];
}

enum AttributeType : int32_t {
  AttributeType_None = 0,
  AttributeType_Fire = 1,
  AttributeType_Water = 2,
  AttributeType_Wind = 3,
  AttributeType_Earth = 4,
  AttributeType_Holy = 5,
  AttributeType_Dark = 6,
  AttributeType_MIN = AttributeType_None,
  AttributeType_MAX = AttributeType_Dark
};

inline const AttributeType (&EnumValuesAttributeType())[7] {
  static const AttributeType values[] = {
    AttributeType_None,
    AttributeType_Fire,
    AttributeType_Water,
    AttributeType_Wind,
    AttributeType_Earth,
    AttributeType_Holy,
    AttributeType_Dark
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[8] = {
    "None",
    "Fire",
    "Water",
    "Wind",
    "Earth",
    "Holy",
    "Dark",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType_None, AttributeType_Dark)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum RaceType : int32_t {
  RaceType_Human = 0,
  RaceType_Elf = 1,
  RaceType_Dwarf = 2,
  RaceType_Orc = 3,
  RaceType_Undead = 4,
  RaceType_Dragon = 5,
  RaceType_MIN = RaceType_Human,
  RaceType_MAX = RaceType_Dragon
};

inline const RaceType (&EnumValuesRaceType())[6] {
  static const RaceType values[] = {
    RaceType_Human,
    RaceType_Elf,
    RaceType_Dwarf,
    RaceType_Orc,
    RaceType_Undead,
    RaceType_Dragon
  };
  return values;
}

inline const char * const *EnumNamesRaceType() {
  static const char * const names[7] = {
    "Human",
    "Elf",
    "Dwarf",
    "Orc",
    "Undead",
    "Dragon",
    nullptr
  };
  return names;
}

inline const char *EnumNameRaceType(RaceType e) {
  if (::flatbuffers::IsOutRange(e, RaceType_Human, RaceType_Dragon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRaceType()[index];
}

enum CurrencyType : int32_t {
  CurrencyType_Gold = 0,
  CurrencyType_Ruby = 1,
  CurrencyType_Mileage = 2,
  CurrencyType_Honor = 3,
  CurrencyType_GuildPoint = 4,
  CurrencyType_MIN = CurrencyType_Gold,
  CurrencyType_MAX = CurrencyType_GuildPoint
};

inline const CurrencyType (&EnumValuesCurrencyType())[5] {
  static const CurrencyType values[] = {
    CurrencyType_Gold,
    CurrencyType_Ruby,
    CurrencyType_Mileage,
    CurrencyType_Honor,
    CurrencyType_GuildPoint
  };
  return values;
}

inline const char * const *EnumNamesCurrencyType() {
  static const char * const names[6] = {
    "Gold",
    "Ruby",
    "Mileage",
    "Honor",
    "GuildPoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrencyType(CurrencyType e) {
  if (::flatbuffers::IsOutRange(e, CurrencyType_Gold, CurrencyType_GuildPoint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurrencyType()[index];
}

enum GradeType : int32_t {
  GradeType_Normal = 0,
  GradeType_Magic = 1,
  GradeType_Rare = 2,
  GradeType_Unique = 3,
  GradeType_Epic = 4,
  GradeType_Legendary = 5,
  GradeType_Mythic = 6,
  GradeType_MIN = GradeType_Normal,
  GradeType_MAX = GradeType_Mythic
};

inline const GradeType (&EnumValuesGradeType())[7] {
  static const GradeType values[] = {
    GradeType_Normal,
    GradeType_Magic,
    GradeType_Rare,
    GradeType_Unique,
    GradeType_Epic,
    GradeType_Legendary,
    GradeType_Mythic
  };
  return values;
}

inline const char * const *EnumNamesGradeType() {
  static const char * const names[8] = {
    "Normal",
    "Magic",
    "Rare",
    "Unique",
    "Epic",
    "Legendary",
    "Mythic",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradeType(GradeType e) {
  if (::flatbuffers::IsOutRange(e, GradeType_Normal, GradeType_Mythic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradeType()[index];
}

enum ItemReason : int32_t {
  ItemReason_AddDrop = 0,
  ItemReason_SubUse = 1,
  ItemReason_MIN = ItemReason_AddDrop,
  ItemReason_MAX = ItemReason_SubUse
};

inline const ItemReason (&EnumValuesItemReason())[2] {
  static const ItemReason values[] = {
    ItemReason_AddDrop,
    ItemReason_SubUse
  };
  return values;
}

inline const char * const *EnumNamesItemReason() {
  static const char * const names[3] = {
    "AddDrop",
    "SubUse",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemReason(ItemReason e) {
  if (::flatbuffers::IsOutRange(e, ItemReason_AddDrop, ItemReason_SubUse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemReason()[index];
}

}  // namespace makga

#endif  // FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
