// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
#define FLATBUFFERS_GENERATED_ENUM_MAKGA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "version_generated.h"

namespace makga {

enum ServerType : int32_t {
  ServerType_Billing = 0,
  ServerType_Login = 1,
  ServerType_World = 2,
  ServerType_Community = 3,
  ServerType_DBAgent = 4,
  ServerType_Game = 5,
  ServerType_Instance = 6,
  ServerType_Web = 7,
  ServerType_Log = 8,
  ServerType_MIN = ServerType_Billing,
  ServerType_MAX = ServerType_Log
};

inline const ServerType (&EnumValuesServerType())[9] {
  static const ServerType values[] = {
    ServerType_Billing,
    ServerType_Login,
    ServerType_World,
    ServerType_Community,
    ServerType_DBAgent,
    ServerType_Game,
    ServerType_Instance,
    ServerType_Web,
    ServerType_Log
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[10] = {
    "Billing",
    "Login",
    "World",
    "Community",
    "DBAgent",
    "Game",
    "Instance",
    "Web",
    "Log",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (::flatbuffers::IsOutRange(e, ServerType_Billing, ServerType_Log)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum DatabaseType : int32_t {
  DatabaseType_NONE = 0,
  DatabaseType_MIN = DatabaseType_NONE,
  DatabaseType_MAX = DatabaseType_NONE
};

inline const DatabaseType (&EnumValuesDatabaseType())[1] {
  static const DatabaseType values[] = {
    DatabaseType_NONE
  };
  return values;
}

inline const char * const *EnumNamesDatabaseType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatabaseType(DatabaseType e) {
  if (::flatbuffers::IsOutRange(e, DatabaseType_NONE, DatabaseType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatabaseType()[index];
}

enum RedisType : int32_t {
  RedisType_NONE = 0,
  RedisType_MIN = RedisType_NONE,
  RedisType_MAX = RedisType_NONE
};

inline const RedisType (&EnumValuesRedisType())[1] {
  static const RedisType values[] = {
    RedisType_NONE
  };
  return values;
}

inline const char * const *EnumNamesRedisType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedisType(RedisType e) {
  if (::flatbuffers::IsOutRange(e, RedisType_NONE, RedisType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRedisType()[index];
}

enum AccountType : int32_t {
  AccountType_NONE = 0,
  AccountType_MIN = AccountType_NONE,
  AccountType_MAX = AccountType_NONE
};

inline const AccountType (&EnumValuesAccountType())[1] {
  static const AccountType values[] = {
    AccountType_NONE
  };
  return values;
}

inline const char * const *EnumNamesAccountType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountType(AccountType e) {
  if (::flatbuffers::IsOutRange(e, AccountType_NONE, AccountType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccountType()[index];
}

enum AIType : int32_t {
  AIType_Aggressive = 0,
  AIType_NonAggressive = 1,
  AIType_Coward = 2,
  AIType_FieldBoss = 3,
  AIType_InstanceBoss = 4,
  AIType_Character = 5,
  AIType_Sandbag = 6,
  AIType_MIN = AIType_Aggressive,
  AIType_MAX = AIType_Sandbag
};

inline const AIType (&EnumValuesAIType())[7] {
  static const AIType values[] = {
    AIType_Aggressive,
    AIType_NonAggressive,
    AIType_Coward,
    AIType_FieldBoss,
    AIType_InstanceBoss,
    AIType_Character,
    AIType_Sandbag
  };
  return values;
}

inline const char * const *EnumNamesAIType() {
  static const char * const names[8] = {
    "Aggressive",
    "NonAggressive",
    "Coward",
    "FieldBoss",
    "InstanceBoss",
    "Character",
    "Sandbag",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIType(AIType e) {
  if (::flatbuffers::IsOutRange(e, AIType_Aggressive, AIType_Sandbag)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIType()[index];
}

enum ActorType : int32_t {
  ActorType_None = 0,
  ActorType_Character = 1,
  ActorType_Monster = 2,
  ActorType_Gadget = 3,
  ActorType_Object = 4,
  ActorType_MIN = ActorType_None,
  ActorType_MAX = ActorType_Object
};

inline const ActorType (&EnumValuesActorType())[5] {
  static const ActorType values[] = {
    ActorType_None,
    ActorType_Character,
    ActorType_Monster,
    ActorType_Gadget,
    ActorType_Object
  };
  return values;
}

inline const char * const *EnumNamesActorType() {
  static const char * const names[6] = {
    "None",
    "Character",
    "Monster",
    "Gadget",
    "Object",
    nullptr
  };
  return names;
}

inline const char *EnumNameActorType(ActorType e) {
  if (::flatbuffers::IsOutRange(e, ActorType_None, ActorType_Object)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActorType()[index];
}

enum CityType : int32_t {
  CityType_NONE = 0,
  CityType_MIN = CityType_NONE,
  CityType_MAX = CityType_NONE
};

inline const CityType (&EnumValuesCityType())[1] {
  static const CityType values[] = {
    CityType_NONE
  };
  return values;
}

inline const char * const *EnumNamesCityType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCityType(CityType e) {
  if (::flatbuffers::IsOutRange(e, CityType_NONE, CityType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCityType()[index];
}

enum PkType : int32_t {
  PkType_Safe = 0,
  PkType_Lawful = 1,
  PkType_Conflict = 2,
  PkType_Hostile = 3,
  PkType_Arena = 4,
  PkType_MIN = PkType_Safe,
  PkType_MAX = PkType_Arena
};

inline const PkType (&EnumValuesPkType())[5] {
  static const PkType values[] = {
    PkType_Safe,
    PkType_Lawful,
    PkType_Conflict,
    PkType_Hostile,
    PkType_Arena
  };
  return values;
}

inline const char * const *EnumNamesPkType() {
  static const char * const names[6] = {
    "Safe",
    "Lawful",
    "Conflict",
    "Hostile",
    "Arena",
    nullptr
  };
  return names;
}

inline const char *EnumNamePkType(PkType e) {
  if (::flatbuffers::IsOutRange(e, PkType_Safe, PkType_Arena)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPkType()[index];
}

enum AreaType : int32_t {
  AreaType_City = 0,
  AreaType_Village = 1,
  AreaType_Field = 2,
  AreaType_Instance = 3,
  AreaType_MIN = AreaType_City,
  AreaType_MAX = AreaType_Instance
};

inline const AreaType (&EnumValuesAreaType())[4] {
  static const AreaType values[] = {
    AreaType_City,
    AreaType_Village,
    AreaType_Field,
    AreaType_Instance
  };
  return values;
}

inline const char * const *EnumNamesAreaType() {
  static const char * const names[5] = {
    "City",
    "Village",
    "Field",
    "Instance",
    nullptr
  };
  return names;
}

inline const char *EnumNameAreaType(AreaType e) {
  if (::flatbuffers::IsOutRange(e, AreaType_City, AreaType_Instance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAreaType()[index];
}

enum AttributeType : int32_t {
  AttributeType_None = 0,
  AttributeType_Fire = 1,
  AttributeType_Water = 2,
  AttributeType_Wind = 3,
  AttributeType_Earth = 4,
  AttributeType_Holy = 5,
  AttributeType_Dark = 6,
  AttributeType_MIN = AttributeType_None,
  AttributeType_MAX = AttributeType_Dark
};

inline const AttributeType (&EnumValuesAttributeType())[7] {
  static const AttributeType values[] = {
    AttributeType_None,
    AttributeType_Fire,
    AttributeType_Water,
    AttributeType_Wind,
    AttributeType_Earth,
    AttributeType_Holy,
    AttributeType_Dark
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[8] = {
    "None",
    "Fire",
    "Water",
    "Wind",
    "Earth",
    "Holy",
    "Dark",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType_None, AttributeType_Dark)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum RaceType : int32_t {
  RaceType_Human = 0,
  RaceType_Elf = 1,
  RaceType_Dwarf = 2,
  RaceType_Orc = 3,
  RaceType_Undead = 4,
  RaceType_Dragon = 5,
  RaceType_MIN = RaceType_Human,
  RaceType_MAX = RaceType_Dragon
};

inline const RaceType (&EnumValuesRaceType())[6] {
  static const RaceType values[] = {
    RaceType_Human,
    RaceType_Elf,
    RaceType_Dwarf,
    RaceType_Orc,
    RaceType_Undead,
    RaceType_Dragon
  };
  return values;
}

inline const char * const *EnumNamesRaceType() {
  static const char * const names[7] = {
    "Human",
    "Elf",
    "Dwarf",
    "Orc",
    "Undead",
    "Dragon",
    nullptr
  };
  return names;
}

inline const char *EnumNameRaceType(RaceType e) {
  if (::flatbuffers::IsOutRange(e, RaceType_Human, RaceType_Dragon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRaceType()[index];
}

enum CurrencyType : int32_t {
  CurrencyType_Gold = 0,
  CurrencyType_Ruby = 1,
  CurrencyType_Mileage = 2,
  CurrencyType_Honor = 3,
  CurrencyType_GuildPoint = 4,
  CurrencyType_MIN = CurrencyType_Gold,
  CurrencyType_MAX = CurrencyType_GuildPoint
};

inline const CurrencyType (&EnumValuesCurrencyType())[5] {
  static const CurrencyType values[] = {
    CurrencyType_Gold,
    CurrencyType_Ruby,
    CurrencyType_Mileage,
    CurrencyType_Honor,
    CurrencyType_GuildPoint
  };
  return values;
}

inline const char * const *EnumNamesCurrencyType() {
  static const char * const names[6] = {
    "Gold",
    "Ruby",
    "Mileage",
    "Honor",
    "GuildPoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrencyType(CurrencyType e) {
  if (::flatbuffers::IsOutRange(e, CurrencyType_Gold, CurrencyType_GuildPoint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurrencyType()[index];
}

enum GradeType : int32_t {
  GradeType_Normal = 0,
  GradeType_Magic = 1,
  GradeType_Rare = 2,
  GradeType_Unique = 3,
  GradeType_Epic = 4,
  GradeType_Legendary = 5,
  GradeType_Mythic = 6,
  GradeType_MIN = GradeType_Normal,
  GradeType_MAX = GradeType_Mythic
};

inline const GradeType (&EnumValuesGradeType())[7] {
  static const GradeType values[] = {
    GradeType_Normal,
    GradeType_Magic,
    GradeType_Rare,
    GradeType_Unique,
    GradeType_Epic,
    GradeType_Legendary,
    GradeType_Mythic
  };
  return values;
}

inline const char * const *EnumNamesGradeType() {
  static const char * const names[8] = {
    "Normal",
    "Magic",
    "Rare",
    "Unique",
    "Epic",
    "Legendary",
    "Mythic",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradeType(GradeType e) {
  if (::flatbuffers::IsOutRange(e, GradeType_Normal, GradeType_Mythic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradeType()[index];
}

enum StatType : int32_t {
  StatType_Strength = 0,
  StatType_Agility = 1,
  StatType_Intelligence = 2,
  StatType_Stamina = 3,
  StatType_Dexterity = 4,
  StatType_Wisdom = 5,
  StatType_Luck = 6,
  StatType_Constitution = 7,
  StatType_Spirit = 8,
  StatType_Charisma = 9,
  StatType_Hp = 10,
  StatType_Mp = 11,
  StatType_HpRegen = 12,
  StatType_MpRegen = 13,
  StatType_AttackSpeed = 14,
  StatType_CastSpeed = 15,
  StatType_MoveSpeed = 16,
  StatType_Accuracy = 17,
  StatType_Penetration = 18,
  StatType_MagicPenetration = 19,
  StatType_SkillDamage = 20,
  StatType_BonusDamage = 21,
  StatType_DamageReduction = 22,
  StatType_BossDamage = 23,
  StatType_PhysicalAtk = 24,
  StatType_PhysicalDef = 25,
  StatType_MagicalAtk = 26,
  StatType_MagicalDef = 27,
  StatType_FireDamage = 28,
  StatType_FireReduction = 29,
  StatType_WaterDamage = 30,
  StatType_WaterReduction = 31,
  StatType_WindDamage = 32,
  StatType_WindReduction = 33,
  StatType_EarthDamage = 34,
  StatType_EarthReduction = 35,
  StatType_HolyDamage = 36,
  StatType_HolyReduction = 37,
  StatType_DarkDamage = 38,
  StatType_DarkReduction = 39,
  StatType_CriRate = 40,
  StatType_CriResist = 41,
  StatType_CriDamage = 42,
  StatType_CriReduction = 43,
  StatType_BlockRate = 44,
  StatType_BlockResist = 45,
  StatType_MIN = StatType_Strength,
  StatType_MAX = StatType_BlockResist
};

inline const StatType (&EnumValuesStatType())[46] {
  static const StatType values[] = {
    StatType_Strength,
    StatType_Agility,
    StatType_Intelligence,
    StatType_Stamina,
    StatType_Dexterity,
    StatType_Wisdom,
    StatType_Luck,
    StatType_Constitution,
    StatType_Spirit,
    StatType_Charisma,
    StatType_Hp,
    StatType_Mp,
    StatType_HpRegen,
    StatType_MpRegen,
    StatType_AttackSpeed,
    StatType_CastSpeed,
    StatType_MoveSpeed,
    StatType_Accuracy,
    StatType_Penetration,
    StatType_MagicPenetration,
    StatType_SkillDamage,
    StatType_BonusDamage,
    StatType_DamageReduction,
    StatType_BossDamage,
    StatType_PhysicalAtk,
    StatType_PhysicalDef,
    StatType_MagicalAtk,
    StatType_MagicalDef,
    StatType_FireDamage,
    StatType_FireReduction,
    StatType_WaterDamage,
    StatType_WaterReduction,
    StatType_WindDamage,
    StatType_WindReduction,
    StatType_EarthDamage,
    StatType_EarthReduction,
    StatType_HolyDamage,
    StatType_HolyReduction,
    StatType_DarkDamage,
    StatType_DarkReduction,
    StatType_CriRate,
    StatType_CriResist,
    StatType_CriDamage,
    StatType_CriReduction,
    StatType_BlockRate,
    StatType_BlockResist
  };
  return values;
}

inline const char * const *EnumNamesStatType() {
  static const char * const names[47] = {
    "Strength",
    "Agility",
    "Intelligence",
    "Stamina",
    "Dexterity",
    "Wisdom",
    "Luck",
    "Constitution",
    "Spirit",
    "Charisma",
    "Hp",
    "Mp",
    "HpRegen",
    "MpRegen",
    "AttackSpeed",
    "CastSpeed",
    "MoveSpeed",
    "Accuracy",
    "Penetration",
    "MagicPenetration",
    "SkillDamage",
    "BonusDamage",
    "DamageReduction",
    "BossDamage",
    "PhysicalAtk",
    "PhysicalDef",
    "MagicalAtk",
    "MagicalDef",
    "FireDamage",
    "FireReduction",
    "WaterDamage",
    "WaterReduction",
    "WindDamage",
    "WindReduction",
    "EarthDamage",
    "EarthReduction",
    "HolyDamage",
    "HolyReduction",
    "DarkDamage",
    "DarkReduction",
    "CriRate",
    "CriResist",
    "CriDamage",
    "CriReduction",
    "BlockRate",
    "BlockResist",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatType(StatType e) {
  if (::flatbuffers::IsOutRange(e, StatType_Strength, StatType_BlockResist)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatType()[index];
}

enum AbilityType : int32_t {
  AbilityType_Stun = 0,
  AbilityType_Knockback = 1,
  AbilityType_Slow = 2,
  AbilityType_Provoke = 3,
  AbilityType_Silence = 4,
  AbilityType_Blessing = 5,
  AbilityType_DoubleHitChance = 6,
  AbilityType_IgnoreShield = 7,
  AbilityType_LifeSteal = 8,
  AbilityType_Shield = 9,
  AbilityType_HealingUp = 10,
  AbilityType_CoolTimeDown = 11,
  AbilityType_Burn = 12,
  AbilityType_Curse = 13,
  AbilityType_Immortal = 14,
  AbilityType_MIN = AbilityType_Stun,
  AbilityType_MAX = AbilityType_Immortal
};

inline const AbilityType (&EnumValuesAbilityType())[15] {
  static const AbilityType values[] = {
    AbilityType_Stun,
    AbilityType_Knockback,
    AbilityType_Slow,
    AbilityType_Provoke,
    AbilityType_Silence,
    AbilityType_Blessing,
    AbilityType_DoubleHitChance,
    AbilityType_IgnoreShield,
    AbilityType_LifeSteal,
    AbilityType_Shield,
    AbilityType_HealingUp,
    AbilityType_CoolTimeDown,
    AbilityType_Burn,
    AbilityType_Curse,
    AbilityType_Immortal
  };
  return values;
}

inline const char * const *EnumNamesAbilityType() {
  static const char * const names[16] = {
    "Stun",
    "Knockback",
    "Slow",
    "Provoke",
    "Silence",
    "Blessing",
    "DoubleHitChance",
    "IgnoreShield",
    "LifeSteal",
    "Shield",
    "HealingUp",
    "CoolTimeDown",
    "Burn",
    "Curse",
    "Immortal",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityType(AbilityType e) {
  if (::flatbuffers::IsOutRange(e, AbilityType_Stun, AbilityType_Immortal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityType()[index];
}

enum TargetType : int32_t {
  TargetType_Caster = 0,
  TargetType_Enemy = 1,
  TargetType_Party = 2,
  TargetType_Guild = 3,
  TargetType_Ally = 4,
  TargetType_All = 5,
  TargetType_MIN = TargetType_Caster,
  TargetType_MAX = TargetType_All
};

inline const TargetType (&EnumValuesTargetType())[6] {
  static const TargetType values[] = {
    TargetType_Caster,
    TargetType_Enemy,
    TargetType_Party,
    TargetType_Guild,
    TargetType_Ally,
    TargetType_All
  };
  return values;
}

inline const char * const *EnumNamesTargetType() {
  static const char * const names[7] = {
    "Caster",
    "Enemy",
    "Party",
    "Guild",
    "Ally",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetType(TargetType e) {
  if (::flatbuffers::IsOutRange(e, TargetType_Caster, TargetType_All)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetType()[index];
}

enum TargetingType : int32_t {
  TargetingType_Self = 0,
  TargetingType_Unit = 1,
  TargetingType_Ground = 2,
  TargetingType_MIN = TargetingType_Self,
  TargetingType_MAX = TargetingType_Ground
};

inline const TargetingType (&EnumValuesTargetingType())[3] {
  static const TargetingType values[] = {
    TargetingType_Self,
    TargetingType_Unit,
    TargetingType_Ground
  };
  return values;
}

inline const char * const *EnumNamesTargetingType() {
  static const char * const names[4] = {
    "Self",
    "Unit",
    "Ground",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetingType(TargetingType e) {
  if (::flatbuffers::IsOutRange(e, TargetingType_Self, TargetingType_Ground)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetingType()[index];
}

enum CostType : int32_t {
  CostType_Gold = 0,
  CostType_Hp = 1,
  CostType_Mp = 2,
  CostType_MIN = CostType_Gold,
  CostType_MAX = CostType_Mp
};

inline const CostType (&EnumValuesCostType())[3] {
  static const CostType values[] = {
    CostType_Gold,
    CostType_Hp,
    CostType_Mp
  };
  return values;
}

inline const char * const *EnumNamesCostType() {
  static const char * const names[4] = {
    "Gold",
    "Hp",
    "Mp",
    nullptr
  };
  return names;
}

inline const char *EnumNameCostType(CostType e) {
  if (::flatbuffers::IsOutRange(e, CostType_Gold, CostType_Mp)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCostType()[index];
}

enum ItemReason : int32_t {
  ItemReason_AddDrop = 0,
  ItemReason_SubUse = 1,
  ItemReason_MIN = ItemReason_AddDrop,
  ItemReason_MAX = ItemReason_SubUse
};

inline const ItemReason (&EnumValuesItemReason())[2] {
  static const ItemReason values[] = {
    ItemReason_AddDrop,
    ItemReason_SubUse
  };
  return values;
}

inline const char * const *EnumNamesItemReason() {
  static const char * const names[3] = {
    "AddDrop",
    "SubUse",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemReason(ItemReason e) {
  if (::flatbuffers::IsOutRange(e, ItemReason_AddDrop, ItemReason_SubUse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemReason()[index];
}

enum MoveType : int32_t {
  MoveType_Walk = 0,
  MoveType_Teleport = 1,
  MoveType_MIN = MoveType_Walk,
  MoveType_MAX = MoveType_Teleport
};

inline const MoveType (&EnumValuesMoveType())[2] {
  static const MoveType values[] = {
    MoveType_Walk,
    MoveType_Teleport
  };
  return values;
}

inline const char * const *EnumNamesMoveType() {
  static const char * const names[3] = {
    "Walk",
    "Teleport",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoveType(MoveType e) {
  if (::flatbuffers::IsOutRange(e, MoveType_Walk, MoveType_Teleport)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoveType()[index];
}

}  // namespace makga

#endif  // FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
