// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
#define FLATBUFFERS_GENERATED_ENUM_MAKGA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "version_generated.h"

namespace makga {

enum ServerType : int32_t {
  ServerType_Billing = 0,
  ServerType_Login = 1,
  ServerType_World = 2,
  ServerType_Community = 3,
  ServerType_DBAgent = 4,
  ServerType_Game = 5,
  ServerType_Instance = 6,
  ServerType_Web = 7,
  ServerType_Log = 8,
  ServerType_MIN = ServerType_Billing,
  ServerType_MAX = ServerType_Log
};

inline const ServerType (&EnumValuesServerType())[9] {
  static const ServerType values[] = {
    ServerType_Billing,
    ServerType_Login,
    ServerType_World,
    ServerType_Community,
    ServerType_DBAgent,
    ServerType_Game,
    ServerType_Instance,
    ServerType_Web,
    ServerType_Log
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[10] = {
    "Billing",
    "Login",
    "World",
    "Community",
    "DBAgent",
    "Game",
    "Instance",
    "Web",
    "Log",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (::flatbuffers::IsOutRange(e, ServerType_Billing, ServerType_Log)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum DatabaseType : int32_t {
  DatabaseType_NONE = 0,
  DatabaseType_MIN = DatabaseType_NONE,
  DatabaseType_MAX = DatabaseType_NONE
};

inline const DatabaseType (&EnumValuesDatabaseType())[1] {
  static const DatabaseType values[] = {
    DatabaseType_NONE
  };
  return values;
}

inline const char * const *EnumNamesDatabaseType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDatabaseType(DatabaseType e) {
  if (::flatbuffers::IsOutRange(e, DatabaseType_NONE, DatabaseType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDatabaseType()[index];
}

enum RedisType : int32_t {
  RedisType_NONE = 0,
  RedisType_MIN = RedisType_NONE,
  RedisType_MAX = RedisType_NONE
};

inline const RedisType (&EnumValuesRedisType())[1] {
  static const RedisType values[] = {
    RedisType_NONE
  };
  return values;
}

inline const char * const *EnumNamesRedisType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRedisType(RedisType e) {
  if (::flatbuffers::IsOutRange(e, RedisType_NONE, RedisType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRedisType()[index];
}

enum AccountType : int32_t {
  AccountType_NONE = 0,
  AccountType_MIN = AccountType_NONE,
  AccountType_MAX = AccountType_NONE
};

inline const AccountType (&EnumValuesAccountType())[1] {
  static const AccountType values[] = {
    AccountType_NONE
  };
  return values;
}

inline const char * const *EnumNamesAccountType() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountType(AccountType e) {
  if (::flatbuffers::IsOutRange(e, AccountType_NONE, AccountType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccountType()[index];
}

enum AIType : int32_t {
  AIType_Aggressive = 0,
  AIType_NonAggressive = 1,
  AIType_Coward = 2,
  AIType_FieldBoss = 3,
  AIType_InstanceBoss = 4,
  AIType_MIN = AIType_Aggressive,
  AIType_MAX = AIType_InstanceBoss
};

inline const AIType (&EnumValuesAIType())[5] {
  static const AIType values[] = {
    AIType_Aggressive,
    AIType_NonAggressive,
    AIType_Coward,
    AIType_FieldBoss,
    AIType_InstanceBoss
  };
  return values;
}

inline const char * const *EnumNamesAIType() {
  static const char * const names[6] = {
    "Aggressive",
    "NonAggressive",
    "Coward",
    "FieldBoss",
    "InstanceBoss",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIType(AIType e) {
  if (::flatbuffers::IsOutRange(e, AIType_Aggressive, AIType_InstanceBoss)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIType()[index];
}

}  // namespace makga

#endif  // FLATBUFFERS_GENERATED_ENUM_MAKGA_H_
